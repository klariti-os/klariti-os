var background=(function(){"use strict";function T(e){return e==null||typeof e=="function"?{main:e}:e}const o=globalThis.browser?.runtime?.id?globalThis.browser:globalThis.chrome,k="https://api-klariti.onrender.com",m={apiUrl:k,wsUrl:(e=>`${e.replace(/^https/,"wss")}/challenges/ws`)(k)},b=e=>{if(e.completed)return"completed";if(e.challenge_type==="time_based"&&e.time_based_details){const t=new Date,r=e.time_based_details.start_date,a=e.time_based_details.end_date,l=new Date(r.endsWith("Z")?r:`${r}Z`),O=new Date(a.endsWith("Z")?a:`${a}Z`);return t>O?"expired":t<l?"scheduled":"active"}return e.challenge_type==="toggle"&&e.toggle_details&&e.toggle_details.is_active?"active":"paused"},w=e=>b(e)==="active",f=e=>w(e),s={STORAGE_KEYS:{ACCESS_TOKEN:"access_token",USERNAME:"username",CHALLENGES:"challenges",CONNECTION_STATUS:"connectionStatus"},async getState(){const e=await o.storage.local.get([this.STORAGE_KEYS.ACCESS_TOKEN,this.STORAGE_KEYS.USERNAME,this.STORAGE_KEYS.CHALLENGES,this.STORAGE_KEYS.CONNECTION_STATUS]);return{access_token:e[this.STORAGE_KEYS.ACCESS_TOKEN]||null,username:e[this.STORAGE_KEYS.USERNAME]||null,challenges:e[this.STORAGE_KEYS.CHALLENGES]||[],connectionStatus:e[this.STORAGE_KEYS.CONNECTION_STATUS]||"disconnected"}},async setChallenges(e){await o.storage.local.set({[this.STORAGE_KEYS.CHALLENGES]:e})},async setConnectionStatus(e){console.log("Setting connection status to:",e?"connected":"disconnected"),await o.storage.local.set({[this.STORAGE_KEYS.CONNECTION_STATUS]:e?"connected":"disconnected"})},async setSession(e,t){await o.storage.local.set({[this.STORAGE_KEYS.ACCESS_TOKEN]:e,[this.STORAGE_KEYS.USERNAME]:t})},async clearSession(){await o.storage.local.remove([this.STORAGE_KEYS.ACCESS_TOKEN,this.STORAGE_KEYS.USERNAME,this.STORAGE_KEYS.CHALLENGES])},getActiveChallenges(e){return Array.isArray(e)?e.filter(f):[]},normalizeUrl(e){if(!e)return"";let t=e.replace(/^https?:\/\//,"");return t=t.replace(/^www\./,""),t=t.replace(/\/$/,""),t.toLowerCase()},getBlockedUrls(e){const t=new Set;return e.filter(f).forEach(a=>{Array.isArray(a.distractions)&&a.distractions.forEach(l=>{l?.url&&t.add(this.normalizeUrl(l.url))})}),t},isUrlBlocked(e,t){if(!e)return!1;const r=this.normalizeUrl(e);if(t.has(r))return!0;for(const a of t)if(r===a||r.startsWith(a)||r.includes(a))return!0;return!1}};let u=new Set,n=null,c=null;const p=T(()=>{E(),o.runtime.onInstalled.addListener(()=>{console.log("Klariti extension installed"),E()}),o.runtime.onStartup.addListener(()=>{console.log("Klariti extension starting"),E()}),o.runtime.onMessage.addListener((e,t,r)=>{if(e.action==="user_logged_in")return d().then(()=>{g(),i(),r({success:!0})}),!0;if(e.action==="user_logged_out")return n&&(n.close(),n=null),c&&(clearTimeout(c),c=null),u.clear(),r({success:!0}),!0;if(e.action==="challenges_updated"&&Array.isArray(e.challenges))return A(e.challenges),i(),r({success:!0}),!0;if(e.action==="refresh_challenges")return d().then(()=>{r({success:!0})}),!0;if(e.action==="check_connection"){(!n||n.readyState!==WebSocket.OPEN)&&g();const a=n&&n.readyState===WebSocket.OPEN;return r({status:a?"connected":"disconnected"}),!0}return!1}),o.alarms.create("keepAlive",{periodInMinutes:5/60}),o.alarms.create("checkActiveTab",{periodInMinutes:10/60}),o.alarms.create("checkTimedChallenges",{periodInMinutes:1}),o.alarms.onAlarm.addListener(e=>{e.name==="keepAlive"?(console.log("Keep alive alarm triggered"),y()):e.name==="checkActiveTab"?(console.log("Check active tab alarm triggered"),i()):e.name==="checkTimedChallenges"&&(console.log("Check timed challenges alarm triggered"),s.getState().then(({challenges:t})=>{Array.isArray(t)&&A(t)}))}),o.tabs.onActivated.addListener(async e=>{try{const t=await o.tabs.get(e.tabId);await h(t)}catch(t){console.error("Error in tab activation handler:",t)}}),o.windows.onFocusChanged.addListener(e=>{console.log("Window focus changed:",e),e!==o.windows.WINDOW_ID_NONE&&o.tabs.query({active:!0,windowId:e}).then(t=>{!t||t.length===0||h(t[0])})}),o.tabs.onUpdated.addListener((e,t,r)=>{!r||!r.active||!t.url&&t.status!=="loading"||h(r)})});async function E(){try{const{access_token:e}=await s.getState();e&&(await d(),g()),await i()}catch(e){console.error("Initialization error:",e)}}async function d(){try{const{access_token:e}=await s.getState();if(!e){console.log("No access token, skipping challenge fetch");return}const t=await fetch(`${m.apiUrl}/challenges/my-challenges?skip=0&limit=100`,{headers:{Authorization:`Bearer ${e}`,"Content-Type":"application/json"}});if(!t.ok){const a=await t.text();console.error("Failed to fetch challenges:",t.status,a),(t.status===401||t.status===403)&&(console.error("Authentication failed - token expired or invalid"),await s.clearSession(),n&&(n.close(),n=null),c&&(clearTimeout(c),c=null),u.clear());return}const r=await t.json();await s.setChallenges(r),A(r)}catch(e){console.error("Error fetching challenges:",e)}}function A(e){u=s.getBlockedUrls(e),console.log(`Updated blocking rules: ${u.size} URLs blocked from ${e.filter(f).length} active challenges`),i()}function C(e){return s.isUrlBlocked(e,u)}async function h(e){if(!e||!e.url)return;const t=e.url;if(!(t.startsWith("chrome://")||t.startsWith("chrome-extension://"))&&C(t))try{await o.tabs.update(e.id,{url:"http://klariti.so/lock"}),console.log("Redirected blocked tab:",t)}catch(r){console.error("Error redirecting blocked tab:",r)}}async function i(){try{const e=await o.tabs.query({active:!0,currentWindow:!0});if(!e||e.length===0)return;await h(e[0])}catch(e){console.error("Error checking active tab:",e)}}async function y(){try{const{access_token:e}=await s.getState();e&&(await d(),(!n||n.readyState!==WebSocket.OPEN)&&g())}catch(e){console.error("Error fetching state from API:",e)}}function g(e=0){try{if(n&&n.readyState===WebSocket.OPEN)return;n&&n.close(),n=new WebSocket(m.wsUrl),n.onopen=()=>{console.log("Challenge WebSocket connected"),s.setConnectionStatus(!0)},n.onmessage=t=>{try{const r=JSON.parse(t.data);(r.type==="challenge_toggled"||r.type==="challenge_updated")&&d().then(()=>i())}catch(r){console.error("Error parsing WebSocket message:",r)}},n.onerror=t=>{console.error("Challenge WebSocket error:",t),s.setConnectionStatus(!1)},n.onclose=()=>{console.log("WebSocket disconnected"),n=null,s.setConnectionStatus(!1),c&&clearTimeout(c);const t=Math.min(3e4,Math.pow(2,e)*1e3),r=Math.random()*1e3,a=t+r;console.log(`Reconnecting in ${Math.round(a)}ms...`),c=setTimeout(()=>{s.getState().then(({access_token:l})=>{l&&g(e+1)})},a)}}catch(t){console.error("Error creating challenge WebSocket:",t),s.setConnectionStatus(!1)}}function K(){}function S(e,...t){}const N={debug:(...e)=>S(console.debug,...e),log:(...e)=>S(console.log,...e),warn:(...e)=>S(console.warn,...e),error:(...e)=>S(console.error,...e)};let _;try{_=p.main(),_ instanceof Promise&&console.warn("The background's main() function return a promise, but it must be synchronous")}catch(e){throw N.error("The background crashed on startup!"),e}return _})();
